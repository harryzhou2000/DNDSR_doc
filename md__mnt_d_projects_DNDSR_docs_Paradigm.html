<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DNDSR: Paradigm in designing DNDS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DNDSR
   &#160;<span id="projectnumber">0.0</span>
   </div>
   <div id="projectbrief">Distributed Numeric Data Structure for CFV</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__mnt_d_projects_DNDSR_docs_Paradigm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Paradigm in designing <a class="el" href="namespaceDNDS.html">DNDS</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="namespaceDNDS.html">DNDS</a> is designed to be a set of commonly used infrastructure that can be used in CFD-like code. When organizing data and algorithms in CFD code, the programmer has to cope with geometry and field data, which correspond to mesh/grid related code and field related code. When the CFD scheme involves unstructured mesh and high order discretization, the grid and field code could become rather complex. Therefore, it is a natural thing to put some levels of abstraction here, and cover up the raw data types using C++ features.</p>
<h1><a class="anchor" id="autotoc_md26"></a>
Basic Data Structure</h1>
<p>There has been countless C++ involved computational applications in the field of computer graphics and CG designing (like <a href="https://github.com/blender/blenderC">blender</a>), CAD (like <a href="https://github.com/FreeCAD/FreeCAD">FreeCAD</a>), CAE mesh generation (like <a href="https://gitlab.onelab.info/gmsh/gmsh">gmsh</a>) that involve very complex unstructured and polymorphic geometry data. And massive computational applications including deep learning architectures (like <a href="https://github.com/pytorch/pytorch">PyTorch</a>) use high levels of abstraction directly on fully structured and homogeneously organized data arrays.</p>
<p>Unstructured CFD applications are different from both types of computational models, where both complex geometry and massive homogeneous numeric operations are required but easier to cover. Unstructured CFD code only involve limited types of geometry elements and connection type, which can be nearly hard-coded; while while global high-rank structured arrays are mostly not needed, only rank 2 to 5 arrays with potentially non-uniform sizes could be utilized.</p>
<p>So, how do we design the interface used in implementing CFD (By CFD, I mean math formulae of discrete schemes)? Here we inspect some references of famous open cfd code chunks:</p>
<p>It seems concerning basic data arrangement, the OpenFOAM and SU2 both require the data to be able to be accessed with random accessors (random_iterator, pointer, subscript or similar):</p>
<p><a href="https://github.com/OpenFOAM/OpenFOAM-dev/blob/master/src/finiteVolume/finiteVolume/gradSchemes/LeastSquaresGrad/LeastSquaresGrad.C">OpenFOAM's gradient calculation</a>:</p>
<div class="fragment"><div class="line">forAll(vtf, celli)</div>
<div class="line">    {</div>
<div class="line">        flatVtf[celli] = vtf[celli];</div>
<div class="line">    }</div>
</div><!-- fragment --><p><a href="https://github.com/su2code/SU2/blob/master/SU2_CFD/include/gradients/computeGradientsGreenGauss.hpp">SU2's gradient calculation</a>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iVertex = 0; iVertex &lt; geometry.GetnVertex(iMarker); ++iVertex)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">//... code</span></div>
<div class="line">        <span class="keywordflow">if</span> (!nodes-&gt;GetDomain(iPoint)) <span class="keywordflow">continue</span>;</div>
<div class="line">        <span class="comment">//... code</span></div>
<div class="line">      }</div>
</div><!-- fragment --><p>And their directly operating data objects seem to be defined on a whole (zone of) mesh:</p>
<p><a href="https://github.com/OpenFOAM/OpenFOAM-dev/blob/master/src/finiteVolume/finiteVolume/gradSchemes/LeastSquaresGrad/LeastSquaresGrad.C">OpenFOAM's gradient calculation</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> List&lt;List&lt;label&gt;&gt;&amp; stencilAddr = stencil.stencil();</div>
<div class="line"><span class="keyword">const</span> List&lt;List&lt;vector&gt;&gt;&amp; lsvs = lsv.vectors();</div>
</div><!-- fragment --><p><a href="https://github.com/su2code/SU2/blob/master/SU2_CFD/include/gradients/computeGradientsGreenGauss.hpp">SU2's gradient calculation</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> iPoint = geometry.vertex[iMarker][iVertex]-&gt;GetNode();</div>
<div class="line"><span class="comment">//</span></div>
<div class="line">su2double volume = nodes-&gt;GetVolume(iPoint) + nodes-&gt;GetPeriodicVolume(iPoint);</div>
</div><!-- fragment --><p>Actually, SU2's <a href="https://github.com/su2code/SU2/blob/master/Common/include/geometry/dual_grid/CVertex.hpp">CVertex</a> is a polymorphic class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CVertex : <span class="keyword">public</span> CDualGrid {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Nodes[1];               <span class="comment">/*!&lt; \brief Vector to store the global nodes of an element. */</span></div>
<div class="line">  su2double Normal[3] = {0.0};          <span class="comment">/*!&lt; \brief Normal coordinates of the element and its center of gravity. */</span></div>
<div class="line">  su2double Aux_Var;                    <span class="comment">/*!&lt; \brief Auxiliar variable defined only on the surface. */</span></div>
<div class="line">  su2double CartCoord[3] = {0.0};       <span class="comment">/*!&lt; \brief Vertex cartesians coordinates. */</span></div>
<div class="line">  su2double VarCoord[3] = {0.0};        <span class="comment">/*!&lt; \brief Used for storing the coordinate variation due to a surface modification. */</span></div>
<div class="line">  <span class="keywordtype">long</span> PeriodicPoint[5] = {-1};         <span class="comment">/*!&lt; \brief Store the periodic point of a boundary (iProcessor, iPoint) */</span></div>
<div class="line">  <span class="keywordtype">bool</span> ActDisk_Perimeter = <span class="keyword">false</span>;       <span class="comment">/*!&lt; \brief Identify nodes at the perimeter of the actuator disk */</span></div>
<div class="line">  <span class="keywordtype">short</span> Rotation_Type;                  <span class="comment">/*!&lt; \brief Type of rotation associated with the vertex (MPI and periodic) */</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Normal_Neighbor;        <span class="comment">/*!&lt; \brief Index of the closest neighbor. */</span></div>
<div class="line">  su2double Basis_Function[3] = {0.0};  <span class="comment">/*!&lt; \brief Basis function values for interpolation across zones. */</span></div>
<div class="line">  <span class="comment">//...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>CDualGrid stores the adjacency information, geometric information and auxiliary information in the class, and overrides base's methods for calculating some useful geometric information. So is SU2's CPrimalGrid class.</p>
<p>However, OpenFOAM seems to maintain a primitive data array for mesh topology and geometry in <a href="https://github.com/OpenFOAM/OpenFOAM-dev/blob/master/src/OpenFOAM/meshes/primitiveMesh/primitiveMesh.H">primitiveMesh</a> class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>primitiveMesh</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Permanent data</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Primitive size data</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">//- Number of internal points (or -1 if points not sorted)</span></div>
<div class="line">        label nInternalPoints_;</div>
<div class="line">        <span class="comment">//- Number of points</span></div>
<div class="line">        label nPoints_;</div>
<div class="line">        <span class="comment">//- Number of internal edges using 0 boundary points</span></div>
<div class="line">        <span class="keyword">mutable</span> label nInternal0Edges_;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Shapes</span></div>
<div class="line">        <span class="comment">//- Cell shapes</span></div>
<div class="line">        <span class="keyword">mutable</span> cellShapeList* cellShapesPtr_;</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Connectivity</span></div>
<div class="line">        <span class="comment">//- Cell-cells</span></div>
<div class="line">        <span class="keyword">mutable</span> labelListList* ccPtr_;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// On-the-fly edge addressing storage</span></div>
<div class="line">        <span class="comment">//- Temporary storage for addressing.</span></div>
<div class="line">        <span class="keyword">mutable</span> DynamicList&lt;label&gt; labels_;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Geometric data</span></div>
<div class="line">        <span class="comment">//- Cell centres</span></div>
<div class="line">        <span class="keyword">mutable</span> vectorField* cellCentresPtr_;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>And OpenFOAM wraps these data with methods to access mesh topo and geom with inheritance.</p>
<p><a class="el" href="namespaceDNDS.html">DNDS</a> does not intend to directly apply such methods at first, but intend to simplify the <b>MPI communications</b> on some <b>limited types</b> of data arrays. Communication for any complex object is secondary in <a class="el" href="namespaceDNDS.html">DNDS</a>, for most of the communication is needed only for arrays of basic types like <code>int_64</code> and <code>float_64</code> and their simple composite c-like-struct, which is implemented in <code>Array</code> and <code>ArrayTransformer</code> classes. Any communication on general objects would be a concept requiring the objects being able to serialize/deserialize themselves to a buffer in a given method and given order (which is closer to the communication model in PHengLEI).</p>
<p>The first application of <a class="el" href="namespaceDNDS.html">DNDS</a>, the simple CFV <em>euler</em> solver, does only invoke basic type communications in <code>ArrayTransformer</code>, and has yet to come up with any MPI-related bug (data corruption, dead lock...) since no hard MPI operation is needed outside the <a class="el" href="namespaceDNDS.html">DNDS</a> wrapping.</p>
<p>Also, <a class="el" href="namespaceDNDS.html">DNDS</a> recommends the user to put different kinds of data in different arrays instead of combining them at first, like in OpenFOAM: </p><div class="fragment"><div class="line">std::vector&lt;real&gt; faceArea;</div>
<div class="line">std::vector&lt;vec&gt;  faceCent;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//not:</span></div>
<div class="line"><span class="keyword">struct </span>Face{</div>
<div class="line">    <a class="code" href="namespaceDNDS.html#ab0ba2f3339b92ca46a38950ef0f89fb3">real</a> area;</div>
<div class="line">    vec  cent;</div>
<div class="line">};</div>
<div class="line">std::vector&lt;Face&gt; faces;</div>
<div class="ttc" id="anamespaceDNDS_html_ab0ba2f3339b92ca46a38950ef0f89fb3"><div class="ttname"><a href="namespaceDNDS.html#ab0ba2f3339b92ca46a38950ef0f89fb3">DNDS::real</a></div><div class="ttdeci">double real</div><div class="ttdef"><b>Definition:</b> <a href="Defines_8hpp_source.html#l00101">Defines.hpp:101</a></div></div>
</div><!-- fragment --><p>Using <a class="el" href="namespaceDNDS.html">DNDS</a> provided data structure, one can consider <code>std::vector&lt;simple_type&gt;</code> to be able to manage its own communication pattern, somewhat like a PETSC Vector.</p>
<p>The reasoning behind this, is to separate different data genres, which may need different arrangements of communication, access and combination. For example, if one uses combined data:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Solution{</div>
<div class="line">    <a class="code" href="namespaceDNDS.html#ab0ba2f3339b92ca46a38950ef0f89fb3">real</a> rho, ru, rv, rw, E, u, <a class="code" href="namespaceDNDS_1_1Meta.html#aee1fbf3a0a4da28af35bc8ca9515c25f">v</a>, w, p, T;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> WriteStream(ByteStream&amp;);</div>
<div class="line">    <span class="keywordtype">void</span> ReadStream(ByteStream&amp;);</div>
<div class="line">};</div>
<div class="line">std::vector&lt;Solution&gt; solutions;</div>
<div class="ttc" id="anamespaceDNDS_1_1Meta_html_aee1fbf3a0a4da28af35bc8ca9515c25f"><div class="ttname"><a href="namespaceDNDS_1_1Meta.html#aee1fbf3a0a4da28af35bc8ca9515c25f">DNDS::Meta::v</a></div><div class="ttdeci">const bool v</div><div class="ttdef"><b>Definition:</b> <a href="EigenUtil_8hpp_source.html#l00065">EigenUtil.hpp:65</a></div></div>
</div><!-- fragment --><p>then Write and Read would only involve the conserved variables. However, if one extends this to:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Solution{</div>
<div class="line">    <a class="code" href="namespaceDNDS.html#ab0ba2f3339b92ca46a38950ef0f89fb3">real</a> rho, ru, rv, rw, E, u, <a class="code" href="namespaceDNDS_1_1Meta.html#aee1fbf3a0a4da28af35bc8ca9515c25f">v</a>, w, p, T;</div>
<div class="line">    <a class="code" href="namespaceDNDS.html#ab0ba2f3339b92ca46a38950ef0f89fb3">real</a> rho_1, ru_1, rv_1, rw_1, E_1;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> WriteStream(ByteStream&amp;);</div>
<div class="line">    <span class="keywordtype">void</span> ReadStream(ByteStream&amp;);</div>
<div class="line">};</div>
</div><!-- fragment --><p>and both X and X_1 variables need to be communicated through MPI, but at different phases of computation, then the <code>WriteStream</code> and <code>ReadStream</code> would not be sufficient for communicating; but in a polymorphic design, like using concept of templates or using virtual inheritance, the top level of abstraction must be general enough to take these matters into account. Also, it is a burden to add new communicated components to the class.</p>
<p>Therefore, in <a class="el" href="namespaceDNDS.html">DNDS</a>, it is recommended that the abstraction is delayed out of the arrays of data, or the abstraction should not be nested into the raw data arrays. Actually, <a class="el" href="namespaceDNDS.html">DNDS</a> is only dedicated to providing a means of using c-like random-access large arrays without the concern of communication, and any higher level of abstraction is left for the user. <br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
